package codegen

import (
	"fmt"
	"net/http"
	"os"
	"reflect"
	"strings"

	"github.com/sevenitynet/octanox/auth"
	"github.com/sevenitynet/octanox/router"
)

// TSConfig holds configuration for TypeScript client code generation.
type TSConfig struct {
	UseCookieAuth bool
	AuthMethod    *auth.AuthenticationMethod
}

type tsCodeBuilder struct {
	sb  strings.Builder
	ind int
}

func (b *tsCodeBuilder) write(s string) {
	b.sb.WriteString(s)
}

func (b *tsCodeBuilder) writeLine(s string) {
	b.write(strings.Repeat(" ", b.ind))
	b.write(s)
	b.write("\n")
}

func (b *tsCodeBuilder) writeLineNoIdent(s string) {
	b.write(s)
	b.write("\n")
}

func (b *tsCodeBuilder) writeLines(strs ...string) {
	for _, s := range strs {
		b.writeLine(s)
	}
}

func (b *tsCodeBuilder) indent() {
	b.ind += 2
}

func (b *tsCodeBuilder) unindent() {
	b.ind -= 2
}

// GenerateTypeScriptClient generates TypeScript client code for the given routes.
func GenerateTypeScriptClient(path string, routes []router.Route, config TSConfig) {
	builder := tsCodeBuilder{
		ind: 0,
		sb:  strings.Builder{},
	}

	builder.writeLines(
		"// This file is generated by Octanox. Do not edit this file manually.",
		"//",
		"// This file contains the TypeScript client code for the Octanox server.",
		"",
		"let baseUrl = window.location.origin",
		"let unauthorizedHandler: () => void",
		"",
		"export function setBaseUrl(url: string) {",
		"  baseUrl = url",
		"}",
		"",
		"export function setUnauthorizedHandler(handler: () => void) {",
		"  unauthorizedHandler = handler",
		"}",
		"",
		"function getBaseConfig(): RequestInit {",
		"  return {",
	)

	// Add credentials: 'include' when cookie auth is enabled
	if config.UseCookieAuth {
		builder.writeLine("    credentials: 'include',")
	}

	if config.AuthMethod != nil {
		authMethod := *config.AuthMethod
		if authMethod == auth.AuthenticationMethodBearer || authMethod == auth.AuthenticationMethodBearerOAuth2 {
			// Only include Authorization header for backwards compatibility when not using cookie auth
			if !config.UseCookieAuth {
				builder.writeLines(
					"    headers: {",
					" 		 'Authorization': `Bearer ${localStorage.getItem('token')}`",
					"    },",
				)
			}
		} else if authMethod == auth.AuthenticationMethodBasic {
			builder.writeLines(
				"    headers: {",
				"      'Authorization': `Basic ${btoa(`${localStorage.getItem('username')}:${localStorage.getItem('password')}`)}`",
				"    },",
			)
		} else if authMethod == auth.AuthenticationMethodApiKey {
			builder.writeLines(
				"    headers: {",
				"      'X-API-Key': localStorage.getItem('apiKey')",
				"    },",
			)
		}
	}

	builder.writeLines(
		"  }",
		"}",
		"",
		"async function fetchJson<T>(url: string, init?: RequestInit): Promise<T> {",
		"  const baseConfig = getBaseConfig()",
		"  const config = init || {}",
	)

	// Add credentials from baseConfig when cookie auth is enabled
	if config.UseCookieAuth {
		builder.writeLine("  config.credentials = baseConfig.credentials")
	}

	builder.writeLines(
		"  if (!config.headers) {",
		"    config.headers = {}",
		"  }",
		"  if (!config.headers['Content-Type']) {",
		"    config.headers['Content-Type'] = 'application/json'",
		"  }",
		"  if (!config.headers['Accept']) {",
		"    config.headers['Accept'] = 'application/json'",
		"  }",
	)

	// Only copy Authorization header when not using cookie auth
	if !config.UseCookieAuth {
		builder.writeLines(
			"	 if (!config.headers['Authorization'] && baseConfig.headers['Authorization']) {",
			"    config.headers['Authorization'] = baseConfig.headers['Authorization']",
			"  }",
		)
	}

	builder.writeLines(
		"  let response = await fetch(baseUrl + url, config)",
		"  if (response.status === 401) {",
		"    unauthorizedHandler()",
		"  }",
		"  if (!response.ok) {",
		"    throw new Error(`Failed to fetch ${url}: ${response.statusText}`)",
		"  }",
		"  return await response.json()",
		"}",
		"",
	)

	// Generate interfaces for the structs in the request body
	for _, route := range routes {
		if route.RequestType != nil && route.ResponseType.Name() != "" {
			builder.generateBodyInterface(route.RequestType)
			builder.writeLine("")
		}

		if route.ResponseType != nil && route.ResponseType.Name() != "" {
			builder.generateStructInterface(route.ResponseType)
			builder.writeLine("")
		}
	}

	// Generate functions for each route
	for _, route := range routes {
		builder.generateRouteFunction(route)
		builder.writeLine("")
	}

	builder.writeLines("// end of generated code")

	err := os.WriteFile(path, []byte(builder.sb.String()), 0644)
	if err != nil {
		panic(err)
	}
}

func (tb *tsCodeBuilder) generateRouteFunction(route router.Route) {
	tb.write("export async function " + tb.generateFunctionName(route) + "(")
	if route.RequestType != nil {
		tb.generateFunctionParameters(route.RequestType)
	}

	tb.write("): Promise<")
	tb.typeFromGo(route.ResponseType)
	tb.writeLine("> {")

	tb.indent()
	tb.writeLine("let url = `" + route.Path + "`")

	for i := 0; i < route.RequestType.NumField(); i++ {
		field := route.RequestType.Field(i)
		if pathParam := field.Tag.Get("path"); pathParam != "" {
			tb.writeLine("url = url.replace(`:" + pathParam + "`, encodeURIComponent(" + field.Name + ".toString()))")
		}
	}

	tb.writeLine("const config: RequestInit = {")
	tb.indent()
	tb.writeLine("method: '" + strings.ToUpper(route.Method) + "',")

	if route.RequestType != nil {
		if route.Method != http.MethodGet && route.RequestType.NumField() > 0 {
			tb.writeLine("body: JSON.stringify(" + tb.getBodyParamName(route.RequestType) + "),")
		}
	}

	tb.unindent()
	tb.writeLine("};")

	if route.RequestType != nil {
		first := true

		for i := 0; i < route.RequestType.NumField(); i++ {
			field := route.RequestType.Field(i)
			if queryParam := field.Tag.Get("query"); queryParam != "" {
				tb.write("url += ")
				if first {
					tb.write("`?")
					first = false
				} else {
					tb.write("`&")
				}

				tb.writeLineNoIdent(tb.getQueryParamString(queryParam, field.Name) + "`")
			}
		}
	}

	tb.write("  return fetchJson<")
	tb.typeFromGo(route.ResponseType)
	tb.unindent()
	tb.writeLine(">(url, config);")
	tb.writeLine("}")
}

func (tb *tsCodeBuilder) generateFunctionName(route router.Route) string {
	path := strings.Replace(route.Path, os.Getenv("NOX__GEN_OMIT_URL"), "", 1)
	path = strings.ReplaceAll(path, "/", "_")
	path = strings.ReplaceAll(path, ":", "")
	name := strings.ToLower(route.Method) + path
	name = strings.Map(func(r rune) rune {
		if r == '@' {
			return -1
		}

		if r >= 'a' && r <= 'z' || r >= 'A' && r <= 'Z' || r >= '0' && r <= '9' || r == '_' {
			return r
		}
		return '_'
	}, name)
	return name
}

func (tb *tsCodeBuilder) generateFunctionParameters(t reflect.Type) {
	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		if field.Anonymous {
			continue
		}

		pathTag := field.Tag.Get("path")
		queryTag := field.Tag.Get("query")
		headerTag := field.Tag.Get("header")
		bodyTag := field.Tag.Get("body")

		if pathTag == "" && queryTag == "" && headerTag == "" && bodyTag == "" {
			continue
		}

		tb.write(field.Name + ": ")
		tb.typeFromGo(field.Type)

		if i < t.NumField()-1 {
			tb.write(", ")
		}
	}
}

func (tb *tsCodeBuilder) getBodyParamName(t reflect.Type) string {
	for i := 0; i < t.NumField(); i++ {
		if bodyTag := t.Field(i).Tag.Get("body"); bodyTag != "" {
			return t.Field(i).Name
		}
	}
	return ""
}

func (tb *tsCodeBuilder) getQueryParamString(queryParam, fieldName string) string {
	return fmt.Sprintf("%s=${encodeURIComponent(%s.toString())}", strings.TrimSpace(queryParam), fieldName)
}

func (tb *tsCodeBuilder) generateStructInterface(t reflect.Type) {
	if t.Kind() != reflect.Struct {
		return
	}

	tb.writeLine("export interface " + t.Name() + " {")
	tb.generateStructBody(t, false)
	tb.writeLine("}")
}

func (tb *tsCodeBuilder) generateBodyInterface(t reflect.Type) {
	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		if bodyTag := field.Tag.Get("body"); bodyTag != "" {
			tb.generateStructInterface(field.Type)
		}
	}
}

func (tb *tsCodeBuilder) generateStructBody(t reflect.Type, inline bool) {
	if t.Kind() != reflect.Struct {
		return
	}

	if !inline {
		tb.indent()
	}

	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)

		// Skip embedded fields
		if field.Anonymous {
			continue
		}

		jsonTag := field.Tag.Get("json")
		jsonName := field.Name
		omitempty := false
		if jsonTag != "" {
			if jsonTag == "-" {
				continue
			}

			jsonName = jsonTag
			if strings.Contains(jsonTag, ",omitempty") {
				omitempty = true
			}
		}

		tb.write(strings.Repeat(" ", tb.ind))
		tb.write(jsonName + ": ")
		tb.typeFromGo(field.Type)
		if omitempty {
			tb.write(" | undefined")
		}

		tb.write(";")
		tb.writeLine("")
	}

	if !inline {
		tb.unindent()
	}
}

func (tb *tsCodeBuilder) typeFromGo(t reflect.Type) {
	switch t.Kind() {
	case reflect.Ptr:
		tb.typeFromGo(t.Elem())
		tb.write(" | null")
		return
	case reflect.String:
		tb.write("string")
		return
	case reflect.Bool:
		tb.write("boolean")
		return
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Float32, reflect.Float64:
		tb.write("number")
		return
	case reflect.Struct:
		// if it's an anonymous struct, generate an inline interface
		if t.Name() == "" {
			tb.write("{")
			tb.generateStructBody(t, true)
			tb.write("}")
			return
		}

		tb.write(t.Name())
	case reflect.Slice:
		tb.write("Array<")
		tb.typeFromGo(t.Elem())
		tb.write(">")
		return
	default:
		tb.write("any")
		return
	}
}
